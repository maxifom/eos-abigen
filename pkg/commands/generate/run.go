package generate

import (
	"encoding/json"
	"fmt"
	"os"
	"path"
	"path/filepath"
	"strings"

	"github.com/spf13/afero"

	. "github.com/dave/jennifer/jen"
	"github.com/maxifom/eos-abigen/pkg/abitypes"
	"github.com/stoewer/go-strcase"
)

type Opts struct {
	ContractFilePath     string
	ContractNameOverride string
	GeneratedFolder      string
	Version              string
	FS                   afero.Fs
}

func concatQual(q string) string {
	return path.Join("github.com/maxifom/eos-abigen", q)
}

func Run(opts Opts) error {
	fs := opts.FS
	if fs == nil {
		fs = afero.NewOsFs()
	}

	contractName := strings.TrimSuffix(filepath.Base(opts.ContractFilePath), filepath.Ext(opts.ContractFilePath))

	abiF, err := afero.ReadFile(fs, opts.ContractFilePath)
	if err != nil {
		return fmt.Errorf("failed to read contract file %s: %w", opts.ContractFilePath, err)
	}

	var abi abitypes.ABI

	err = json.Unmarshal(abiF, &abi)
	if err != nil {
		return fmt.Errorf("failed to unmarshal contract JSON: %w", err)
	}

	fPath := filepath.Join(opts.GeneratedFolder, contractName)

	err = fs.MkdirAll(fPath, os.ModePerm)
	if err != nil {
		if !os.IsExist(err) {
			return fmt.Errorf("failed to create output folder %s: %w", fPath, err)
		}
	}

	err = generateStructs(abi, contractName, opts.GeneratedFolder, opts.Version, fs)
	if err != nil {
		return fmt.Errorf("failed to generate structs: %w", err)
	}

	realContractName := contractName
	if opts.ContractNameOverride != "" {
		realContractName = opts.ContractNameOverride
	}

	err = generateTables(abi, contractName, realContractName, opts.GeneratedFolder, opts.Version, fs)
	if err != nil {
		return fmt.Errorf("failed to generate tables: %w", err)
	}

	return nil
}

func generateTables(abi abitypes.ABI, contractName string, realContractName string, generatedFolder string, version string, fs afero.Fs) error {
	f := NewFile(contractName)
	f.HeaderComment(fmt.Sprintf("Generated by eos-abigen version %s", version))

	f.ImportAlias(concatQual("pkg/client"), "rpcClient")
	f.Const().Defs(
		Id("contractName").Op("=").Lit(realContractName),
	)
	f.Add(Type().Id("Client").Struct(
		Op("*").Qual(concatQual("pkg/client"), "RPCClient"),
	))

	constructor := Func().Id("NewClient").Params(Id("rpcClient").Op("*").Qual(concatQual("pkg/client"), "RPCClient")).Params(Id("*" + ("Client"))).Block(
		Return(Op("&").Id("Client").Values(
			Dict{
				Id("RPCClient"): Id("rpcClient"),
			},
		)),
	)
	f.Add(constructor)

	declaredRowsNames := map[string]struct{}{}

	for _, table := range abi.Tables {
		returnType := strcase.UpperCamelCase(table.Type)
		rowsName := returnType + "Rows"
		if _, ok := declaredRowsNames[rowsName]; !ok {
			f.Type().Id(rowsName).Struct(
				Qual(concatQual("pkg/base"), "BaseRows"),
				Id("Rows").Id("[]"+returnType).Tag(map[string]string{"json": "rows"}),
			)

			declaredRowsNames[rowsName] = struct{}{}
		}

		tableActionName := strings.ReplaceAll(strcase.UpperCamelCase(table.Name), ".", "")
		body := Empty()
		body.Id("result").Op(":=").Op("&").Id(rowsName).Values().Line().Line()

		body.Id("options").Op("=").Append(
			Index().Qual(concatQual("pkg/client"), "RequestOption").Values(
				Qual(concatQual("pkg/client"), "Table").Call(Lit(table.Name)),
				Qual(concatQual("pkg/client"), "Scope").Call(Id("contractName")),
				Qual(concatQual("pkg/client"), "Code").Call(Id("contractName")),
				Qual(concatQual("pkg/client"), "Limit").Call(Lit(-1)),
			),

			Id("options").Op("...")).Line()

		body.Err().Op(":=").Id("c").Dot("GetTableRows").Call(Id("ctx"), Id("result"), Id("options").Op("...")).Line()
		body.If(Err().Op("!=").Nil()).Block(
			Return(Nil(), Err()),
		).Line()
		returnStatement := Return(Id("result"), Nil())
		body.Add(returnStatement)
		id := Func().
			Params(Id("c").Id("*"+("Client"))).
			Id(tableActionName).
			Params(Id("ctx").Qual("context", "Context"), Id("options").Op("...").Qual(concatQual("pkg/client"), "RequestOption")).
			Params(Id("*"+rowsName), Id("error")).Block(body)
		f.Add(id)
	}

	fPath := filepath.Join(generatedFolder, contractName, "client.go")
	file, err := fs.OpenFile(fPath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, os.ModePerm)
	if err != nil {
		return err
	}
	defer file.Close()

	err = f.Render(file)
	if err != nil {
		return err
	}
	return nil

}

func generateStructs(abi abitypes.ABI, contractName string, generatedFolder string, version string, fs afero.Fs) error {
	f := NewFile(contractName)
	f.HeaderComment(fmt.Sprintf("Generated by eos-abigen version %s", version))

	newTypesMap := map[string]string{}
	for _, t := range abi.Types {
		newTypesMap[t.NewTypeName] = t.Type
	}

	newStructsMap := map[string]string{}
	for _, abiStruct := range abi.Structs {
		newStructsMap[abiStruct.Name] = strcase.UpperCamelCase(abiStruct.Name)
	}

	for _, abiStruct := range abi.Structs {
		s := Type().Id(strcase.UpperCamelCase(abiStruct.Name))
		fields := make([]Code, 0, len(abiStruct.Fields))
		for _, field := range abiStruct.Fields {
			fieldName := strcase.UpperCamelCase(field.Name)
			fieldGen := Id(fieldName)
			fieldType := field.Type

			listsCount := strings.Count(fieldType, "[]")
			fieldType = strings.ReplaceAll(fieldType, "[]", "")
			if realFieldType, ok := newTypesMap[fieldType]; ok {
				fieldType = realFieldType
			}

			for i := 0; i < listsCount; i++ {
				fieldGen.Index()
			}

			switch fieldType {
			case "bool":
				fieldGen.Qual(concatQual("pkg/base"), "Bool")
			case "int8":
				fieldGen.Int8()
			case "uint8":
				fieldGen.Uint8()
			case "int16":
				fieldGen.Int16()
			case "uint16":
				fieldGen.Uint16()
			case "int32", "varint32":
				fieldGen.Int32()
			case "uint32", "varuint32":
				fieldGen.Uint32()
			case "int64":
				fieldGen.Int64()
			case "uint64":
				fieldGen.Qual(concatQual("pkg/base"), "UInt64")
			case "int128", "uint128":
				fieldGen.Qual(concatQual("pkg/base"), "BigInt")
			case "float32":
				fieldGen.Qual(concatQual("pkg/base"), "Float32")
			case "float64":
				fieldGen.Qual(concatQual("pkg/base"), "Float64")
			case "float128":
				fieldGen.String()
			case "time_point":
				fieldGen.Qual(concatQual("pkg/base"), "TimePoint")
			case "time_point_sec":
				fieldGen.Qual(concatQual("pkg/base"), "TimePointSec")
			case "block_timestamp_type":
				fieldGen.Qual(concatQual("pkg/base"), "BlockTimestampType")
			case "name":
				fieldGen.String()
			case "bytes":
				fieldGen.String()
			case "string":
				fieldGen.String()
			case "checksum160":
				fieldGen.String()
			case "checksum256":
				fieldGen.String()
			case "checksum512":
				fieldGen.String()
			case "public_key":
				fieldGen.String()
			case "signature":
				fieldGen.String()
			case "symbol":
				fieldGen.Qual(concatQual("pkg/base"), "Symbol")
			case "symbol_code":
				fieldGen.String()
			case "asset":
				fieldGen.Qual(concatQual("pkg/base"), "Asset")
			case "extended_asset":
				fieldGen.Qual(concatQual("pkg/base"), "ExtendedAsset")
			default:
				if structName, ok := newStructsMap[fieldType]; ok {
					fieldGen.Id(structName)
				} else {
					fieldGen.Qual("encoding/json", "RawMessage")
				}
			}

			fieldGen.Tag(map[string]string{"json": field.Name})
			fields = append(fields, fieldGen)
		}

		s.Struct(fields...)
		f.Add(s)
	}

	fPath := filepath.Join(generatedFolder, contractName, "types.go")
	file, err := fs.OpenFile(fPath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, os.ModePerm)
	if err != nil {
		return err
	}
	defer file.Close()

	err = f.Render(file)
	if err != nil {
		return err
	}
	return nil
}
