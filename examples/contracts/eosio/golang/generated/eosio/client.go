// Generated by eos-abigen version master

package eosio

import (
	"context"
	base "github.com/maxifom/eos-abigen/pkg/base"
	rpcClient "github.com/maxifom/eos-abigen/pkg/client"
)

const (
	contractName = "eosio"
)

type Client struct {
	*rpcClient.RPCClient
}

func NewClient(rpcClient *rpcClient.RPCClient) *Client {
	return &Client{RPCClient: rpcClient}
}

type AbiHashRows struct {
	base.BaseRows
	Rows []AbiHash `json:"rows"`
}

func (c *Client) Abihash(ctx context.Context, options ...rpcClient.RequestOption) (*AbiHashRows, error) {
	result := &AbiHashRows{}

	options = append([]rpcClient.RequestOption{rpcClient.Table("abihash"), rpcClient.Scope(contractName), rpcClient.Code(contractName), rpcClient.Limit(-1)}, options...)
	err := c.GetTableRows(ctx, result, options...)
	if err != nil {
		return nil, err
	}
	return result, nil
}

type BidRefundRows struct {
	base.BaseRows
	Rows []BidRefund `json:"rows"`
}

func (c *Client) Bidrefunds(ctx context.Context, options ...rpcClient.RequestOption) (*BidRefundRows, error) {
	result := &BidRefundRows{}

	options = append([]rpcClient.RequestOption{rpcClient.Table("bidrefunds"), rpcClient.Scope(contractName), rpcClient.Code(contractName), rpcClient.Limit(-1)}, options...)
	err := c.GetTableRows(ctx, result, options...)
	if err != nil {
		return nil, err
	}
	return result, nil
}

type RexLoanRows struct {
	base.BaseRows
	Rows []RexLoan `json:"rows"`
}

func (c *Client) Cpuloan(ctx context.Context, options ...rpcClient.RequestOption) (*RexLoanRows, error) {
	result := &RexLoanRows{}

	options = append([]rpcClient.RequestOption{rpcClient.Table("cpuloan"), rpcClient.Scope(contractName), rpcClient.Code(contractName), rpcClient.Limit(-1)}, options...)
	err := c.GetTableRows(ctx, result, options...)
	if err != nil {
		return nil, err
	}
	return result, nil
}

type DelegatedBandwidthRows struct {
	base.BaseRows
	Rows []DelegatedBandwidth `json:"rows"`
}

func (c *Client) Delband(ctx context.Context, options ...rpcClient.RequestOption) (*DelegatedBandwidthRows, error) {
	result := &DelegatedBandwidthRows{}

	options = append([]rpcClient.RequestOption{rpcClient.Table("delband"), rpcClient.Scope(contractName), rpcClient.Code(contractName), rpcClient.Limit(-1)}, options...)
	err := c.GetTableRows(ctx, result, options...)
	if err != nil {
		return nil, err
	}
	return result, nil
}

type EosioGlobalStateRows struct {
	base.BaseRows
	Rows []EosioGlobalState `json:"rows"`
}

func (c *Client) Global(ctx context.Context, options ...rpcClient.RequestOption) (*EosioGlobalStateRows, error) {
	result := &EosioGlobalStateRows{}

	options = append([]rpcClient.RequestOption{rpcClient.Table("global"), rpcClient.Scope(contractName), rpcClient.Code(contractName), rpcClient.Limit(-1)}, options...)
	err := c.GetTableRows(ctx, result, options...)
	if err != nil {
		return nil, err
	}
	return result, nil
}

type EosioGlobalState2Rows struct {
	base.BaseRows
	Rows []EosioGlobalState2 `json:"rows"`
}

func (c *Client) Global2(ctx context.Context, options ...rpcClient.RequestOption) (*EosioGlobalState2Rows, error) {
	result := &EosioGlobalState2Rows{}

	options = append([]rpcClient.RequestOption{rpcClient.Table("global2"), rpcClient.Scope(contractName), rpcClient.Code(contractName), rpcClient.Limit(-1)}, options...)
	err := c.GetTableRows(ctx, result, options...)
	if err != nil {
		return nil, err
	}
	return result, nil
}

type EosioGlobalState3Rows struct {
	base.BaseRows
	Rows []EosioGlobalState3 `json:"rows"`
}

func (c *Client) Global3(ctx context.Context, options ...rpcClient.RequestOption) (*EosioGlobalState3Rows, error) {
	result := &EosioGlobalState3Rows{}

	options = append([]rpcClient.RequestOption{rpcClient.Table("global3"), rpcClient.Scope(contractName), rpcClient.Code(contractName), rpcClient.Limit(-1)}, options...)
	err := c.GetTableRows(ctx, result, options...)
	if err != nil {
		return nil, err
	}
	return result, nil
}

type EosioGlobalState4Rows struct {
	base.BaseRows
	Rows []EosioGlobalState4 `json:"rows"`
}

func (c *Client) Global4(ctx context.Context, options ...rpcClient.RequestOption) (*EosioGlobalState4Rows, error) {
	result := &EosioGlobalState4Rows{}

	options = append([]rpcClient.RequestOption{rpcClient.Table("global4"), rpcClient.Scope(contractName), rpcClient.Code(contractName), rpcClient.Limit(-1)}, options...)
	err := c.GetTableRows(ctx, result, options...)
	if err != nil {
		return nil, err
	}
	return result, nil
}

type NameBidRows struct {
	base.BaseRows
	Rows []NameBid `json:"rows"`
}

func (c *Client) Namebids(ctx context.Context, options ...rpcClient.RequestOption) (*NameBidRows, error) {
	result := &NameBidRows{}

	options = append([]rpcClient.RequestOption{rpcClient.Table("namebids"), rpcClient.Scope(contractName), rpcClient.Code(contractName), rpcClient.Limit(-1)}, options...)
	err := c.GetTableRows(ctx, result, options...)
	if err != nil {
		return nil, err
	}
	return result, nil
}
func (c *Client) Netloan(ctx context.Context, options ...rpcClient.RequestOption) (*RexLoanRows, error) {
	result := &RexLoanRows{}

	options = append([]rpcClient.RequestOption{rpcClient.Table("netloan"), rpcClient.Scope(contractName), rpcClient.Code(contractName), rpcClient.Limit(-1)}, options...)
	err := c.GetTableRows(ctx, result, options...)
	if err != nil {
		return nil, err
	}
	return result, nil
}

type PowerupOrderRows struct {
	base.BaseRows
	Rows []PowerupOrder `json:"rows"`
}

func (c *Client) Powuporder(ctx context.Context, options ...rpcClient.RequestOption) (*PowerupOrderRows, error) {
	result := &PowerupOrderRows{}

	options = append([]rpcClient.RequestOption{rpcClient.Table("powup.order"), rpcClient.Scope(contractName), rpcClient.Code(contractName), rpcClient.Limit(-1)}, options...)
	err := c.GetTableRows(ctx, result, options...)
	if err != nil {
		return nil, err
	}
	return result, nil
}

type PowerupStateRows struct {
	base.BaseRows
	Rows []PowerupState `json:"rows"`
}

func (c *Client) Powupstate(ctx context.Context, options ...rpcClient.RequestOption) (*PowerupStateRows, error) {
	result := &PowerupStateRows{}

	options = append([]rpcClient.RequestOption{rpcClient.Table("powup.state"), rpcClient.Scope(contractName), rpcClient.Code(contractName), rpcClient.Limit(-1)}, options...)
	err := c.GetTableRows(ctx, result, options...)
	if err != nil {
		return nil, err
	}
	return result, nil
}

type ProducerInfoRows struct {
	base.BaseRows
	Rows []ProducerInfo `json:"rows"`
}

func (c *Client) Producers(ctx context.Context, options ...rpcClient.RequestOption) (*ProducerInfoRows, error) {
	result := &ProducerInfoRows{}

	options = append([]rpcClient.RequestOption{rpcClient.Table("producers"), rpcClient.Scope(contractName), rpcClient.Code(contractName), rpcClient.Limit(-1)}, options...)
	err := c.GetTableRows(ctx, result, options...)
	if err != nil {
		return nil, err
	}
	return result, nil
}

type ProducerInfo2Rows struct {
	base.BaseRows
	Rows []ProducerInfo2 `json:"rows"`
}

func (c *Client) Producers2(ctx context.Context, options ...rpcClient.RequestOption) (*ProducerInfo2Rows, error) {
	result := &ProducerInfo2Rows{}

	options = append([]rpcClient.RequestOption{rpcClient.Table("producers2"), rpcClient.Scope(contractName), rpcClient.Code(contractName), rpcClient.Limit(-1)}, options...)
	err := c.GetTableRows(ctx, result, options...)
	if err != nil {
		return nil, err
	}
	return result, nil
}

type ExchangeStateRows struct {
	base.BaseRows
	Rows []ExchangeState `json:"rows"`
}

func (c *Client) Rammarket(ctx context.Context, options ...rpcClient.RequestOption) (*ExchangeStateRows, error) {
	result := &ExchangeStateRows{}

	options = append([]rpcClient.RequestOption{rpcClient.Table("rammarket"), rpcClient.Scope(contractName), rpcClient.Code(contractName), rpcClient.Limit(-1)}, options...)
	err := c.GetTableRows(ctx, result, options...)
	if err != nil {
		return nil, err
	}
	return result, nil
}

type RefundRequestRows struct {
	base.BaseRows
	Rows []RefundRequest `json:"rows"`
}

func (c *Client) Refunds(ctx context.Context, options ...rpcClient.RequestOption) (*RefundRequestRows, error) {
	result := &RefundRequestRows{}

	options = append([]rpcClient.RequestOption{rpcClient.Table("refunds"), rpcClient.Scope(contractName), rpcClient.Code(contractName), rpcClient.Limit(-1)}, options...)
	err := c.GetTableRows(ctx, result, options...)
	if err != nil {
		return nil, err
	}
	return result, nil
}

type RexReturnBucketsRows struct {
	base.BaseRows
	Rows []RexReturnBuckets `json:"rows"`
}

func (c *Client) Retbuckets(ctx context.Context, options ...rpcClient.RequestOption) (*RexReturnBucketsRows, error) {
	result := &RexReturnBucketsRows{}

	options = append([]rpcClient.RequestOption{rpcClient.Table("retbuckets"), rpcClient.Scope(contractName), rpcClient.Code(contractName), rpcClient.Limit(-1)}, options...)
	err := c.GetTableRows(ctx, result, options...)
	if err != nil {
		return nil, err
	}
	return result, nil
}

type RexBalanceRows struct {
	base.BaseRows
	Rows []RexBalance `json:"rows"`
}

func (c *Client) Rexbal(ctx context.Context, options ...rpcClient.RequestOption) (*RexBalanceRows, error) {
	result := &RexBalanceRows{}

	options = append([]rpcClient.RequestOption{rpcClient.Table("rexbal"), rpcClient.Scope(contractName), rpcClient.Code(contractName), rpcClient.Limit(-1)}, options...)
	err := c.GetTableRows(ctx, result, options...)
	if err != nil {
		return nil, err
	}
	return result, nil
}

type RexFundRows struct {
	base.BaseRows
	Rows []RexFund `json:"rows"`
}

func (c *Client) Rexfund(ctx context.Context, options ...rpcClient.RequestOption) (*RexFundRows, error) {
	result := &RexFundRows{}

	options = append([]rpcClient.RequestOption{rpcClient.Table("rexfund"), rpcClient.Scope(contractName), rpcClient.Code(contractName), rpcClient.Limit(-1)}, options...)
	err := c.GetTableRows(ctx, result, options...)
	if err != nil {
		return nil, err
	}
	return result, nil
}

type RexPoolRows struct {
	base.BaseRows
	Rows []RexPool `json:"rows"`
}

func (c *Client) Rexpool(ctx context.Context, options ...rpcClient.RequestOption) (*RexPoolRows, error) {
	result := &RexPoolRows{}

	options = append([]rpcClient.RequestOption{rpcClient.Table("rexpool"), rpcClient.Scope(contractName), rpcClient.Code(contractName), rpcClient.Limit(-1)}, options...)
	err := c.GetTableRows(ctx, result, options...)
	if err != nil {
		return nil, err
	}
	return result, nil
}

type RexOrderRows struct {
	base.BaseRows
	Rows []RexOrder `json:"rows"`
}

func (c *Client) Rexqueue(ctx context.Context, options ...rpcClient.RequestOption) (*RexOrderRows, error) {
	result := &RexOrderRows{}

	options = append([]rpcClient.RequestOption{rpcClient.Table("rexqueue"), rpcClient.Scope(contractName), rpcClient.Code(contractName), rpcClient.Limit(-1)}, options...)
	err := c.GetTableRows(ctx, result, options...)
	if err != nil {
		return nil, err
	}
	return result, nil
}

type RexReturnPoolRows struct {
	base.BaseRows
	Rows []RexReturnPool `json:"rows"`
}

func (c *Client) Rexretpool(ctx context.Context, options ...rpcClient.RequestOption) (*RexReturnPoolRows, error) {
	result := &RexReturnPoolRows{}

	options = append([]rpcClient.RequestOption{rpcClient.Table("rexretpool"), rpcClient.Scope(contractName), rpcClient.Code(contractName), rpcClient.Limit(-1)}, options...)
	err := c.GetTableRows(ctx, result, options...)
	if err != nil {
		return nil, err
	}
	return result, nil
}

type UserResourcesRows struct {
	base.BaseRows
	Rows []UserResources `json:"rows"`
}

func (c *Client) Userres(ctx context.Context, options ...rpcClient.RequestOption) (*UserResourcesRows, error) {
	result := &UserResourcesRows{}

	options = append([]rpcClient.RequestOption{rpcClient.Table("userres"), rpcClient.Scope(contractName), rpcClient.Code(contractName), rpcClient.Limit(-1)}, options...)
	err := c.GetTableRows(ctx, result, options...)
	if err != nil {
		return nil, err
	}
	return result, nil
}

type VoterInfoRows struct {
	base.BaseRows
	Rows []VoterInfo `json:"rows"`
}

func (c *Client) Voters(ctx context.Context, options ...rpcClient.RequestOption) (*VoterInfoRows, error) {
	result := &VoterInfoRows{}

	options = append([]rpcClient.RequestOption{rpcClient.Table("voters"), rpcClient.Scope(contractName), rpcClient.Code(contractName), rpcClient.Limit(-1)}, options...)
	err := c.GetTableRows(ctx, result, options...)
	if err != nil {
		return nil, err
	}
	return result, nil
}
